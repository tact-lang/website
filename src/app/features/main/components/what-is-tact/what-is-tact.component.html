<section>
  <h2 class="font-header tact-header">What is Tact?</h2>
  <article>
    <h3>Familiar syntax</h3>
    <p>
      Tact offers familiar syntax inspired by JavaScript, Rust and Swift. Powerful features such as
      algebraic data types and compile-time execution look organic and friendly to new developers.
    </p>
    <app-code-snippet
      content='fn hello(recipient: Address) {
    recipient.send(Message.new("hello, world!"));
}'
      [adaptiveContent]="[
        {
          maxWidth: 600,
          content:
            'fn hello(recipient: Address) {\n' +
            '    recipient.send(\n' +
            '        Message.new(&quot;hello, world!&quot;)\n' +
            '    );\n' +
            '}'
        }
      ]"
    ></app-code-snippet>
  </article>

  <article>
    <h3>Strong type system</h3>
    <p>
      Tact offers algebraic data types compatible with TL-B scheme. Arithmetic is always safe
      because integers have precise bounds. Tact compiler helps you perform necessary checks and
      does not produce silent failures or unexpected truncation.
    </p>
    <app-code-snippet
      content="struct Wallet {
   val seqno: Int(32);
   val pubkey: PublicKey;
   val plugins: List(Plugin);
}"
    ></app-code-snippet>
  </article>

  <article>
    <h3>Actor-oriented</h3>
    <p>
      Tact is designed specifically for the TON actor model. Strongly typed messages enforce
      communication contracts between actors.
    </p>
    <app-code-snippet
      content="interface Ping {
    fn ping(sender: Pong, msg: PingMessage);
}"
      [adaptiveContent]="[
        {
          maxWidth: 600,
          content:
            'interface Ping {\n' +
            '    fn ping(\n' +
            '        sender: Pong,\n' +
            '        msg: PingMessage\n' +
            '    );\n' +
            '}'
        }
      ]"
    ></app-code-snippet>
  </article>

  <article>
    <h3>Gas control</h3>
    <p>
      Blockchain programs have strict execution cost model. Every operation must be paid for in real
      time and execution may fail mid-way if it runs out of gas.
    </p>
    <p>
      Tact makes cross-contract messages safe with precise gas commitments and compiler checks of
      the execution costs. Variable costs are either have static bounds, or checked explicitly in
      runtime.
    </p>
  </article>

  <article>
    <h3>Zero-overhead type composition</h3>
    <p>
      Tact runs your program twice. First run is a compile-time execution that allows freely
      combining types and interfaces to precisely express invariants of the program. Types are then
      checked by the compiler. The resulting Fift or FunC code does not have any runtime overhead.
    </p>
    <p>
      This model offers a single unified language with first-class types and avoids pitfall of
      separate mini-languages for type bounds and macros.
    </p>
  </article>

  <article>
    <h3>Tact and FunC</h3>
    <p>
      FunC is a lower-level language aimed at developers who are deeply familiar with TON
      architecture. FunC liberates developers from writing raw Fift code, while providing the same
      level of control. Unfortunately, the precision of FunC makes it harder to write complex
      multi-contract systems.
    </p>
    <p>
      Tact enables developers to go even further: you can write the entire suites of smart contracts
      with strongly typed interfaces and statically verified execution costs. With Tact you can
      focus on your problem and worry less about blockchain idiosyncrasies.
    </p>
  </article>

  <article>
    <h3>Tact is just getting started</h3>
    <p>
      Tact is a very new project. It is not fully designed yet and certainly not ready for use. We
      announce it early in order to collect the feedback and make it useful to developers
      incrementally.
    </p>
    <p>
      To start, see the <a>Tact Roadmap</a> and <a>Tact Design</a>. Track our progress on
      <a>Tact Github</a>.
    </p>
  </article>
</section>
